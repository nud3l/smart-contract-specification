-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParSpec where
import AbsSpec
import LexSpec
import ErrM

}

%name pSpecification Specification
%name pListSpecification ListSpecification
%name pListStatement ListStatement
%name pStatement Statement
%name pConfigurationExp ConfigurationExp
%name pTargetType TargetType
%name pLanguageType LanguageType
%name pMeterType MeterType
%name pListConfigurationExp ListConfigurationExp
%name pStorageTypedExp StorageTypedExp
%name pTermTyped TermTyped
%name pMappingTyped MappingTyped
%name pStorageUntypedExp StorageUntypedExp
%name pMapping Mapping
%name pListStorageTypedExp ListStorageTypedExp
%name pListStorageUntypedExp ListStorageUntypedExp
%name pFunctionSignature FunctionSignature
%name pPureFunction PureFunction
%name pTransitionFunction TransitionFunction
%name pInputs Inputs
%name pOutputs Outputs
%name pReturns Returns
%name pAssign Assign
%name pPreCondition PreCondition
%name pPostCondition PostCondition
%name pListReturns ListReturns
%name pListPureFunction ListPureFunction
%name pListTransitionFunction ListTransitionFunction
%name pListInputs ListInputs
%name pListOutputs ListOutputs
%name pListAssign ListAssign
%name pListPreCondition ListPreCondition
%name pListPostCondition ListPostCondition
%name pBasicExp BasicExp
%name pBooleanExp BooleanExp
%name pArithmeticExp ArithmeticExp
%name pListBooleanExp ListBooleanExp
%name pBoolean Boolean
%name pArithmetic Arithmetic
%name pBuiltinTypes BuiltinTypes
%name pLiteral Literal
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '
' { PT _ (TS _ 1) }
  '(' { PT _ (TS _ 2) }
  ')' { PT _ (TS _ 3) }
  '*' { PT _ (TS _ 4) }
  '+' { PT _ (TS _ 5) }
  ',' { PT _ (TS _ 6) }
  '-' { PT _ (TS _ 7) }
  '/' { PT _ (TS _ 8) }
  ':' { PT _ (TS _ 9) }
  '<' { PT _ (TS _ 10) }
  '<=' { PT _ (TS _ 11) }
  '==' { PT _ (TS _ 12) }
  '=>' { PT _ (TS _ 13) }
  '>' { PT _ (TS _ 14) }
  '>=' { PT _ (TS _ 15) }
  '@config' { PT _ (TS _ 16) }
  '@global' { PT _ (TS _ 17) }
  '@pure' { PT _ (TS _ 18) }
  '@storage' { PT _ (TS _ 19) }
  '@transition' { PT _ (TS _ 20) }
  'Address' { PT _ (TS _ 21) }
  'Asset' { PT _ (TS _ 22) }
  'Bool' { PT _ (TS _ 23) }
  'Bytes' { PT _ (TS _ 24) }
  'EVM' { PT _ (TS _ 25) }
  'EWASM' { PT _ (TS _ 26) }
  'False' { PT _ (TS _ 27) }
  'Flint' { PT _ (TS _ 28) }
  'Gas' { PT _ (TS _ 29) }
  'IELE' { PT _ (TS _ 30) }
  'Int' { PT _ (TS _ 31) }
  'Scilla' { PT _ (TS _ 32) }
  'Solidity' { PT _ (TS _ 33) }
  'String' { PT _ (TS _ 34) }
  'True' { PT _ (TS _ 35) }
  'Vyper' { PT _ (TS _ 36) }
  '[' { PT _ (TS _ 37) }
  ']' { PT _ (TS _ 38) }
  'assign:' { PT _ (TS _ 39) }
  'ensures:' { PT _ (TS _ 40) }
  'initial(' { PT _ (TS _ 41) }
  'inputs:' { PT _ (TS _ 42) }
  'language' { PT _ (TS _ 43) }
  'meter' { PT _ (TS _ 44) }
  'outputs:' { PT _ (TS _ 45) }
  'requires:' { PT _ (TS _ 46) }
  'target' { PT _ (TS _ 47) }

L_quoted { PT _ (TL $$) }
L_integ  { PT _ (TI $$) }


%%

String  :: { String }  : L_quoted {  $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }

Specification :: { Specification }
Specification : ListStatement { AbsSpec.Spec $1 }
ListSpecification :: { [Specification] }
ListSpecification : {- empty -} { [] }
                  | ListSpecification Specification { flip (:) $1 $2 }
ListStatement :: { [Statement] }
ListStatement : Statement { (:[]) $1 }
              | Statement '
' ListStatement { (:) $1 $3 }
Statement :: { Statement }
Statement : '@config' ListConfigurationExp { AbsSpec.Config $2 }
          | '@storage' ListStorageTypedExp { AbsSpec.Store $2 }
          | '@global' ListBooleanExp { AbsSpec.Global $2 }
          | '@pure' FunctionSignature PureFunction { AbsSpec.Pure $2 $3 }
          | '@transition' FunctionSignature TransitionFunction { AbsSpec.Trans $2 $3 }
ConfigurationExp :: { ConfigurationExp }
ConfigurationExp : 'target' ':' TargetType { AbsSpec.Target $3 }
                 | 'language' ':' LanguageType { AbsSpec.Language $3 }
                 | 'meter' ':' MeterType { AbsSpec.Meter $3 }
TargetType :: { TargetType }
TargetType : 'EVM' { AbsSpec.TarEVM }
           | 'EWASM' { AbsSpec.TarEWASM }
           | 'IELE' { AbsSpec.TarIELE }
           | 'Scilla' { AbsSpec.TarScilla }
LanguageType :: { LanguageType }
LanguageType : 'Solidity' { AbsSpec.LanSol }
             | 'Vyper' { AbsSpec.LanVy }
             | 'Flint' { AbsSpec.LanFlin }
MeterType :: { MeterType }
MeterType : 'Gas' { AbsSpec.Gas }
ListConfigurationExp :: { [ConfigurationExp] }
ListConfigurationExp : ConfigurationExp '
' { (:[]) $1 }
                     | ConfigurationExp '
' ListConfigurationExp { (:) $1 $3 }
StorageTypedExp :: { StorageTypedExp }
StorageTypedExp : TermTyped { AbsSpec.SVar $1 }
                | MappingTyped { AbsSpec.SMap $1 }
TermTyped :: { TermTyped }
TermTyped : String ':' BuiltinTypes { AbsSpec.SVarDecl $1 $3 }
MappingTyped :: { MappingTyped }
MappingTyped : String '[' StorageTypedExp ']' '=>' TermTyped { AbsSpec.SMapDecl $1 $3 $6 }
StorageUntypedExp :: { StorageUntypedExp }
StorageUntypedExp : String { AbsSpec.SUvar $1 }
                  | Mapping { AbsSpec.SUmap $1 }
Mapping :: { Mapping }
Mapping : String '[' StorageUntypedExp ']' { AbsSpec.SUmapDecl $1 $3 }
ListStorageTypedExp :: { [StorageTypedExp] }
ListStorageTypedExp : {- empty -} { [] }
                    | StorageTypedExp { (:[]) $1 }
                    | StorageTypedExp ',' ListStorageTypedExp { (:) $1 $3 }
                    | StorageTypedExp '
' { (:[]) $1 }
                    | StorageTypedExp '
' ListStorageTypedExp { (:) $1 $3 }
ListStorageUntypedExp :: { [StorageUntypedExp] }
ListStorageUntypedExp : {- empty -} { [] }
                      | StorageUntypedExp { (:[]) $1 }
                      | StorageUntypedExp ',' ListStorageUntypedExp { (:) $1 $3 }
FunctionSignature :: { FunctionSignature }
FunctionSignature : String '(' ListStorageUntypedExp ')' { AbsSpec.FunSig $1 $3 }
PureFunction :: { PureFunction }
PureFunction : Inputs Outputs PostCondition { AbsSpec.PureFun $1 $2 $3 }
TransitionFunction :: { TransitionFunction }
TransitionFunction : Inputs Assign PreCondition PostCondition { AbsSpec.TransFun $1 $2 $3 $4 }
Inputs :: { Inputs }
Inputs : 'inputs:' ListStorageTypedExp { AbsSpec.In $2 }
Outputs :: { Outputs }
Outputs : 'outputs:' ListReturns { AbsSpec.Out $2 }
Returns :: { Returns }
Returns : StorageUntypedExp { AbsSpec.SReturn $1 }
        | StorageTypedExp { AbsSpec.MReturn $1 }
Assign :: { Assign }
Assign : 'assign:' ListStorageUntypedExp { AbsSpec.Assig $2 }
PreCondition :: { PreCondition }
PreCondition : 'requires:' ListBooleanExp { AbsSpec.PreCon $2 }
PostCondition :: { PostCondition }
PostCondition : 'ensures:' ListBooleanExp { AbsSpec.PostCon $2 }
ListReturns :: { [Returns] }
ListReturns : {- empty -} { [] }
            | Returns { (:[]) $1 }
            | Returns '
' ListReturns { (:) $1 $3 }
ListPureFunction :: { [PureFunction] }
ListPureFunction : {- empty -} { [] }
                 | ListPureFunction PureFunction '
' { flip (:) $1 $2 }
ListTransitionFunction :: { [TransitionFunction] }
ListTransitionFunction : {- empty -} { [] }
                       | ListTransitionFunction TransitionFunction '
' { flip (:) $1 $2 }
ListInputs :: { [Inputs] }
ListInputs : Inputs '
' { (:[]) $1 }
           | Inputs '
' ListInputs { (:) $1 $3 }
ListOutputs :: { [Outputs] }
ListOutputs : Outputs '
' { (:[]) $1 }
            | Outputs '
' ListOutputs { (:) $1 $3 }
ListAssign :: { [Assign] }
ListAssign : Assign '
' { (:[]) $1 }
           | Assign '
' ListAssign { (:) $1 $3 }
ListPreCondition :: { [PreCondition] }
ListPreCondition : PreCondition '
' { (:[]) $1 }
                 | PreCondition '
' ListPreCondition { (:) $1 $3 }
ListPostCondition :: { [PostCondition] }
ListPostCondition : PostCondition '
' { (:[]) $1 }
                  | PostCondition '
' ListPostCondition { (:) $1 $3 }
BasicExp :: { BasicExp }
BasicExp : Literal { AbsSpec.BLitExp $1 }
         | StorageUntypedExp { AbsSpec.BTermExp $1 }
         | ArithmeticExp { AbsSpec.BArithExp $1 }
         | 'initial(' StorageUntypedExp ')' { AbsSpec.BInitExp $2 }
BooleanExp :: { BooleanExp }
BooleanExp : BasicExp Boolean BasicExp { AbsSpec.BoolExp $1 $2 $3 }
ArithmeticExp :: { ArithmeticExp }
ArithmeticExp : BasicExp Arithmetic BasicExp { AbsSpec.ArithExp $1 $2 $3 }
ListBooleanExp :: { [BooleanExp] }
ListBooleanExp : BooleanExp '
' { (:[]) $1 }
               | BooleanExp '
' ListBooleanExp { (:) $1 $3 }
Boolean :: { Boolean }
Boolean : '==' { AbsSpec.Eq }
        | '>=' { AbsSpec.GEq }
        | '<=' { AbsSpec.LEq }
        | '>' { AbsSpec.Ge }
        | '<' { AbsSpec.Le }
Arithmetic :: { Arithmetic }
Arithmetic : '+' { AbsSpec.Add }
           | '-' { AbsSpec.Sub }
           | '*' { AbsSpec.Mul }
           | '/' { AbsSpec.Div }
BuiltinTypes :: { BuiltinTypes }
BuiltinTypes : 'Int' { AbsSpec.IntType }
             | 'Address' { AbsSpec.AddrType }
             | 'Bool' { AbsSpec.BoolType }
             | 'Asset' { AbsSpec.AssetType }
             | 'String' { AbsSpec.StringType }
             | 'Bytes' { AbsSpec.BytesType }
Literal :: { Literal }
Literal : Integer { AbsSpec.IntLit $1 }
        | 'True' { AbsSpec.TrueLit }
        | 'False' { AbsSpec.FalseLit }
        | String { AbsSpec.StringLit $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    t:_ -> " before `" ++ id(prToken t) ++ "'"

myLexer = tokens
}

